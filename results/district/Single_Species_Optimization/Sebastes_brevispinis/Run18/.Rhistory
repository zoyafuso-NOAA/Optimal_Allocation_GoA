Data_Geostat <- data.frame( "spp" = data$SPECIES_NAME,
"Year" = data$YEAR,
"Catch_KG" = data$WEIGHT,
"AreaSwept_km2" = data$EFFORT,
"Vessel" = 0,
"Lat" = data$LATITUDE,
"Lon" = data$LONGITUDE,
stringsAsFactors = T)
Data_Geostat[, c("LOG_DEPTH", "LOG_DEPTH2") ] <-
data[, c("LOG_DEPTH_EFH_CEN", "LOG_DEPTH_EFH_CEN_SQ")]
##################################################
####   Assign 10 fold partitions of the data
##################################################
n_fold <- 10
years <- paste0(unique(Data_Geostat$Year))
NTime <- length(unique(Data_Geostat$Year))
#Create unique stationID from the latlon. To make sure the ids are unique,
#we use the table function to make sure there are 7900 records (as of 2019)=
Data_Geostat$latlon <- paste0(Data_Geostat$Lat, Data_Geostat$Lon)
table(table(Data_Geostat$latlon))
#split Data_Geostat by year, then on each year-split, randomly assign
#fold numbers to the each unique station
set.seed(2342)
foldno <- lapply(
#Split Data_Geostat by Year
X = split.data.frame(Data_Geostat,
f = Data_Geostat$Year),
#For each year split, randomly assign fold numbers so that each year is
#equally split into n_folds folds
FUN = function(x) {
unique_loc <- unique(x$latlon)
fold_no <- sample(x = 1:n_fold,
size = length(unique_loc),
replace = T)
return(split(unique_loc, fold_no))
})
#Attach fold number to the Data_Geostat
for (iyear in years) {
for (ifold in paste(1:n_fold)) {
Data_Geostat[Data_Geostat$latlon %in% foldno[[iyear]][[ifold]] ,
"fold"] = as.integer(ifold)
}
}
#Columns should roughly have the same number of samples
table(Data_Geostat$fold, Data_Geostat$Year)
##################################################
####   Spatial settings: The following settings define the spatial resolution
####   for the model, and whether to use a grid or mesh approximation
####   Stratification for results
##################################################
settings <- FishStatsUtils::make_settings(
n_x = 500,   # Number of knots
Region = "User", #User inputted extrapolation grid
purpose = "index2",
fine_scale = TRUE,
strata.limits =  data.frame("STRATA" = c("All_areas"),
"west_border" = -Inf,
"east_border" = Inf),
bias.correct = FALSE,
FieldConfig = c(
"Omega1" = 1,   #Spatial random effect on occurence
"Epsilon1" = 1, #Spatiotemporal random effect on occurence
"Omega2" = 1,   #Spatial random effect on positive response
"Epsilon2" = 1  #Spatiotemporal random effect on positive response
),
RhoConfig = c("Beta1" = 0,
"Beta2" = 0,
"Epsilon1" = 0,
"Epsilon2" = 0), #Each year is a fixed effect
OverdispersionConfig = c("Eta1" = 0,
"Eta2" = 0), #Turn off overdispersion
"Options" = c("Calculate_Range" = F,
"Calculate_effective_area" = F),
ObsModel = c(2, 0),
max_cells = Inf,
use_anisotropy = T)
##################################################
####   Import "true" and not interpolated covariate
####   data if using depth covariates
##################################################
load( paste0(github_dir, "data/Extrapolation_depths.RData"))
n_g <- nrow(Extrapolation_depths) #number of grid cells
n_t <- diff(range(Data_Geostat$Year)) + 1 #Number of total years
n_p <- 2 #two density covariates
X_gtp <- array(dim = c(n_g, n_t, n_p) )
for (i in 1:n_t) {
X_gtp[, i, ] <-
as.matrix(Extrapolation_depths[,c("LOG_DEPTH_EFH_CEN",
"LOG_DEPTH_EFH_CEN_SQ")])
}
##################################################
####   Fit the model and save output
##################################################
fit = switch(paste0(depth_in_model),
"FALSE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = result_dir,
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"v_i" = Data_Geostat[, "Vessel"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths),
"TRUE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = result_dir,
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"v_i" = Data_Geostat[, "Vessel"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths,
##Additional arguments for covariates
"X1_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"X2_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"covariate_data" = cbind(Data_Geostat[,c("Lat",
"Lon",
"LOG_DEPTH",
"LOG_DEPTH2",
"Catch_KG")],
Year = NA),
"X_gtp" = X_gtp )
)
##################################################
####   Save
##################################################
save(list = c("fit", "Data_Geostat"),
file = paste0(result_dir, "/fit.RData"))
##################################################
####   10-fold Cross Validation
##################################################
n_fold <- 10
for (fI in 1:n_fold) {
if (!dir.exists(paste0(result_dir, "CV_", fI))) {
dir.create(paste0(result_dir, "CV_", fI))
file.copy(from = paste0(result_dir, get_latest_version(),
c(".cpp", ".dll", ".o")),
to = paste0(result_dir, "CV_", fI, "/",
get_latest_version(),
c(".cpp", ".dll", ".o")))
}
}
# Loop through partitions, refitting each time with a different PredTF_i
for (fI in 1:n_fold ) {
PredTF_i <- ifelse( test = Data_Geostat$fold == fI,
yes = TRUE,
no = FALSE )
fit_new = switch(paste0(depth_in_model),
"FALSE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = paste0(result_dir, "CV_", fI, "/"),
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"v_i" = Data_Geostat[, "Vessel"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths,
"PredTF_i" = PredTF_i,
"Parameters" = fit$ParHat,
"getsd" = T),
"TRUE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = paste0(result_dir, "CV_", fI, "/"),
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"v_i" = Data_Geostat[, "Vessel"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths,
"PredTF_i" = PredTF_i,
"Parameters" = fit$ParHat,
"getsd" = T,
##Additional arguments for covariates
"X1_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"X2_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"covariate_data" = cbind(Data_Geostat[,c("Lat",
"Lon",
"LOG_DEPTH",
"LOG_DEPTH2",
"Catch_KG")],
Year = NA),
"X_gtp" = X_gtp )
)
# Save fit
save(list = "fit_new",
file = paste0(result_dir, "CV_", fI, "/fit.RData"))
}
}
}
source('~/GitHub/MS_OM_GoA/ForMadison/fit_models.R', echo=TRUE)
source('~/GitHub/MS_OM_GoA/ForMadison/fit_models.R', echo=TRUE)
source('~/GitHub/MS_OM_GoA/ForMadison/fit_models.R', echo=TRUE)
#################################################
## Loop over species to fit models with and without depth covariates
#################################################
for (ispp in 23:length(sci_names)) {
for (depth_in_model in c(F, T)) {
##################################################
## Create directory to store model results
##################################################
result_dir <- paste0(VAST_dir,
sci_names_filename[ispp],
ifelse(test = depth_in_model,
yes = "_depth",
no = ""),
"/")
if (!dir.exists(result_dir)) dir.create(result_dir)
##################################################
## Create diagnostics objects
##################################################
if(!dir.exists(paste0(result_dir, "/diagnostics"))) {
dir.create(paste0(result_dir, "/diagnostics"))
}
##################################################
####   Subset species
##################################################
data <- subset(master_data,
SPECIES_NAME == sci_names[ispp])
##################################################
####   Prepare the dataframe for catch-rate data in the VAST format
##################################################
Data_Geostat <- data.frame( "spp" = data$SPECIES_NAME,
"Year" = data$YEAR,
"Catch_KG" = data$WEIGHT,
"AreaSwept_km2" = data$EFFORT,
"Vessel" = 0,
"Lat" = data$LATITUDE,
"Lon" = data$LONGITUDE,
stringsAsFactors = T)
Data_Geostat[, c("LOG_DEPTH", "LOG_DEPTH2") ] <-
data[, c("LOG_DEPTH_EFH_CEN", "LOG_DEPTH_EFH_CEN_SQ")]
##################################################
####   Assign 10 fold partitions of the data
##################################################
n_fold <- 10
years <- paste0(unique(Data_Geostat$Year))
NTime <- length(unique(Data_Geostat$Year))
#Create unique stationID from the latlon. To make sure the ids are unique,
#we use the table function to make sure there are 7900 records (as of 2019)=
Data_Geostat$latlon <- paste0(Data_Geostat$Lat, Data_Geostat$Lon)
table(table(Data_Geostat$latlon))
#split Data_Geostat by year, then on each year-split, randomly assign
#fold numbers to the each unique station
set.seed(2342)
foldno <- lapply(
#Split Data_Geostat by Year
X = split.data.frame(Data_Geostat,
f = Data_Geostat$Year),
#For each year split, randomly assign fold numbers so that each year is
#equally split into n_folds folds
FUN = function(x) {
unique_loc <- unique(x$latlon)
fold_no <- sample(x = 1:n_fold,
size = length(unique_loc),
replace = T)
return(split(unique_loc, fold_no))
})
#Attach fold number to the Data_Geostat
for (iyear in years) {
for (ifold in paste(1:n_fold)) {
Data_Geostat[Data_Geostat$latlon %in% foldno[[iyear]][[ifold]] ,
"fold"] = as.integer(ifold)
}
}
#Columns should roughly have the same number of samples
table(Data_Geostat$fold, Data_Geostat$Year)
##################################################
####   Spatial settings: The following settings define the spatial resolution
####   for the model, and whether to use a grid or mesh approximation
####   Stratification for results
##################################################
settings <- FishStatsUtils::make_settings(
n_x = 500,   # Number of knots
Region = "User", #User inputted extrapolation grid
purpose = "index2",
fine_scale = TRUE,
strata.limits =  data.frame("STRATA" = c("All_areas"),
"west_border" = -Inf,
"east_border" = Inf),
bias.correct = FALSE,
FieldConfig = c(
"Omega1" = 1,   #Spatial random effect on occurence
"Epsilon1" = 1, #Spatiotemporal random effect on occurence
"Omega2" = 1,   #Spatial random effect on positive response
"Epsilon2" = 1  #Spatiotemporal random effect on positive response
),
RhoConfig = c("Beta1" = 0,
"Beta2" = 0,
"Epsilon1" = 0,
"Epsilon2" = 0), #Each year is a fixed effect
OverdispersionConfig = c("Eta1" = 0,
"Eta2" = 0), #Turn off overdispersion
"Options" = c("Calculate_Range" = F,
"Calculate_effective_area" = F),
ObsModel = c(2, 0),
max_cells = Inf,
use_anisotropy = T)
##################################################
####   Import "true" and not interpolated covariate
####   data if using depth covariates
##################################################
load( paste0(github_dir, "data/Extrapolation_depths.RData"))
n_g <- nrow(Extrapolation_depths) #number of grid cells
n_t <- diff(range(Data_Geostat$Year)) + 1 #Number of total years
n_p <- 2 #two density covariates
X_gtp <- array(dim = c(n_g, n_t, n_p) )
for (i in 1:n_t) {
X_gtp[, i, ] <-
as.matrix(Extrapolation_depths[,c("LOG_DEPTH_EFH_CEN",
"LOG_DEPTH_EFH_CEN_SQ")])
}
##################################################
####   Fit the model and save output
##################################################
fit = switch(paste0(depth_in_model),
"FALSE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = result_dir,
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"v_i" = Data_Geostat[, "Vessel"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths),
"TRUE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = result_dir,
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"v_i" = Data_Geostat[, "Vessel"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths,
##Additional arguments for covariates
"X1_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"X2_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"covariate_data" = cbind(Data_Geostat[,c("Lat",
"Lon",
"LOG_DEPTH",
"LOG_DEPTH2",
"Catch_KG")],
Year = NA),
"X_gtp" = X_gtp )
)
##################################################
####   Save
##################################################
save(list = c("fit", "Data_Geostat"),
file = paste0(result_dir, "/fit.RData"))
##################################################
####   10-fold Cross Validation
##################################################
n_fold <- 10
for (fI in 1:n_fold) {
if (!dir.exists(paste0(result_dir, "CV_", fI))) {
dir.create(paste0(result_dir, "CV_", fI))
file.copy(from = paste0(result_dir, get_latest_version(),
c(".cpp", ".dll", ".o")),
to = paste0(result_dir, "CV_", fI, "/",
get_latest_version(),
c(".cpp", ".dll", ".o")))
}
}
# Loop through partitions, refitting each time with a different PredTF_i
for (fI in 1:n_fold ) {
PredTF_i <- ifelse( test = Data_Geostat$fold == fI,
yes = TRUE,
no = FALSE )
fit_new = switch(paste0(depth_in_model),
"FALSE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = paste0(result_dir, "CV_", fI, "/"),
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"v_i" = Data_Geostat[, "Vessel"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths,
"PredTF_i" = PredTF_i,
"Parameters" = fit$ParHat,
"getsd" = T),
"TRUE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = paste0(result_dir, "CV_", fI, "/"),
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"v_i" = Data_Geostat[, "Vessel"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths,
"PredTF_i" = PredTF_i,
"Parameters" = fit$ParHat,
"getsd" = T,
##Additional arguments for covariates
"X1_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"X2_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"covariate_data" = cbind(Data_Geostat[,c("Lat",
"Lon",
"LOG_DEPTH",
"LOG_DEPTH2",
"Catch_KG")],
Year = NA),
"X_gtp" = X_gtp )
)
# Save fit
save(list = "fit_new",
file = paste0(result_dir, "CV_", fI, "/fit.RData"))
}
}
}
###############################################################################
## Project:       Spatiotemporal Survey Optimization
## Author:        Zack Oyafuso (zack.oyafuso@noaa.gov)
## Description:   Conduct SamplingStrata R package multispecies stratified
##                survey optimization
###############################################################################
rm(list = ls())
##################################################
####  Install a forked version of the SamplingStrata Package from
####  zoyafuso-NOAA's Github page
####
####  Import other required packages
##################################################
library(devtools)
devtools::install_github(repo = "zoyafuso-NOAA/SamplingStrata")
library(SamplingStrata)
library(sp)
library(RColorBrewer)
library(raster)
##################################################
####   Set up directories based on whether the optimization is being conducted
####        on a multi-species or single-species level
##################################################
which_machine <- c("Zack_MAC" = 1, "Zack_PC" = 2, "Zack_GI_PC" = 3)[3]
github_dir <- paste0(c("/Users/zackoyafuso/Documents",
"C:/Users/Zack Oyafuso/Documents",
"C:/Users/zack.oyafuso/Work")[which_machine],
"/GitHub/Optimal_Allocation_GoA/")
##################################################
####   Load Data
####   Load Population CVs for use in the thresholds
##################################################
load(paste0(github_dir, "/data/optimization_data.RData"))
load(paste0(github_dir, "/data/Extrapolation_depths.RData"))
##################################################
####   Constants to specify before doing optimization
##################################################
which_domain <- c("full_domain", "district")[1]
which_species = 14
##################################################
####   Constants to set up based on which_domain and which_species
##################################################
frame <- switch( which_domain,
"full_domain" = frame_all,
"district" = frame_district)[, c("domainvalue", "id",
"X1", "X2", "WEIGHT",
paste0("Y", which_species),
paste0("Y", which_species,
"_SQ_SUM"))]
names(frame)[6:7] <- paste0("Y", c("1", "1_SQ_SUM") )
n_dom <- length(unique(frame$domainvalue))
no_strata <- switch(which_domain,
"full_domain" = 10,
"district" = rep(5, n_dom))
result_dir = paste0(github_dir,
"results/", which_domain,
"/Single_Species_Optimization/",
gsub(x = sci_names_all[which_species],
pattern = ' ',
replacement = '_'), '/')
result_dir
source('~/.active-rstudio-document', echo=TRUE)
