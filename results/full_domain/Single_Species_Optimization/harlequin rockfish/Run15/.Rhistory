####   Since the analysis is not contained within a directory, path names
####   are set up here to be used throughout. The script is housed in a a
####   github directory whereas the model output is sent to Z. Oyafuso's G
####   Drive due to storage limits on github.
##################################################
which_machine <- c("Zack_PC" = 1, "Zack_GI_PC" = 2)[2]
github_dir <- c("C:/Users/Zack Oyafuso/Documents/GitHub/MS_OM_GoA/",
"C:/Users/zack.oyafuso/Work/GitHub/MS_OM_GoA/")[which_machine]
VAST_dir <- c("C:/Users/Zack Oyafuso/Desktop/VAST_Runs/Single_Species/",
"G:/Oyafuso/VAST_Runs_EFH/Single_Species/")[which_machine]
if(!dir.exists(VAST_dir)) dir.create(VAST_dir, recursive = T)
##################################################
####   Load packages, make sure versions are consistent
##################################################
library(VAST)
{
switch(EXPR = R.version$version.string == "R version 4.0.2 (2020-06-22)",
"TRUE" = print("R version is consistent with R version 4.0.2"),
"FALSE" = print(
paste0("R version ",
R.version$version.string,
" is not consistent with R version 4.0.2 (2020-06-22).",
"Update R version to be consistent")))
switch(EXPR = packageVersion("VAST") == "3.6.1",
"TRUE" = print("R package VAST is consistent with version 3.6.1"),
"FALSE" = print(
paste0("R version ", packageVersion("VAST"),
" is not consistent with version 3.6.1.",
"Update R package VAST to be consistent")))
switch(EXPR = packageVersion( "FishStatsUtils") == "2.8.0",
"TRUE" = "R package FishStatsUtils is consistent with version 2.8.0",
"FALSE" = print(
paste0("R version ", packageVersion( "FishStatsUtils"),
" is not consistent with version 2.8.0.",
"Update R package FishStatsUtils to be consistent")))
}
##################################################
####   Import CPUE dataset, species set spreadsheet
##################################################
master_data <- read.csv(file = paste0(github_dir, "data/GOA_multspp.csv") )
#################################################
## Loop over species to fit models with and without depth covariates
#################################################
spp_names <- sort(unique(master_data$COMMON_NAME))
spp_names
for (ispp in spp_names[5]) {
for (depth_in_model in c(F, T)[2]) {
##################################################
## Create directory to store model results
##################################################
result_dir <- paste0(VAST_dir,
ispp,
ifelse(test = depth_in_model,
yes = "_depth",
no = ""),
"/")
if (!dir.exists(result_dir)) dir.create(result_dir)
##################################################
## Create diagnostics objects
##################################################
if(!dir.exists(paste0(result_dir, "/diagnostics"))) {
dir.create(paste0(result_dir, "/diagnostics"))
}
##################################################
####   Subset species
##################################################
data <- subset(master_data,
COMMON_NAME == ispp)
##################################################
####   Prepare the dataframe for catch-rate data in the VAST format
##################################################
Data_Geostat <- data.frame( spp = data$SPECIES_NAME,
Year = data$YEAR,
Catch_KG = data$WEIGHT,
AreaSwept_km2 = data$EFFORT,
Lat = data$LATITUDE,
Lon = data$LONGITUDE,
stringsAsFactors = T)
Data_Geostat[, c("LOG_DEPTH", "LOG_DEPTH2") ] <-
data[, c("LOG_DEPTH_EFH_CEN", "LOG_DEPTH_EFH_CEN_SQ")]
##################################################
####   Assign 10 fold partitions of the data
##################################################
n_fold <- 10
years <- paste0(unique(Data_Geostat$Year))
NTime <- length(unique(Data_Geostat$Year))
#Create unique stationID from the latlon. To make sure the ids are unique,
#we use the table function to make sure there are 7900 records (as of 2019)=
Data_Geostat$latlon <- paste0(Data_Geostat$Lat, Data_Geostat$Lon)
table(table(Data_Geostat$latlon))
#split Data_Geostat by year, then on each year-split, randomly assign
#fold numbers to the each unique station
set.seed(2342)
foldno <- lapply(
#Split Data_Geostat by Year
X = split.data.frame(Data_Geostat,
f = Data_Geostat$Year),
#For each year split, randomly assign fold numbers so that each year is
#equally split into n_folds folds
FUN = function(x) {
unique_loc <- unique(x$latlon)
fold_no <- sample(x = 1:n_fold,
size = length(unique_loc),
replace = T)
return(split(unique_loc, fold_no))
})
#Attach fold number to the Data_Geostat
for (iyear in years) {
for (ifold in paste(1:n_fold)) {
Data_Geostat[Data_Geostat$latlon %in% foldno[[iyear]][[ifold]] ,
"fold"] = as.integer(ifold)
}
}
#Columns should roughly have the same number of samples
# table(Data_Geostat$fold, Data_Geostat$Year)
##################################################
####   Spatial settings: The following settings define the spatial resolution
####   for the model, and whether to use a grid or mesh approximation
####   Stratification for results
##################################################
settings <- FishStatsUtils::make_settings(
Version = "VAST_v12_0_0",
n_x = 500,   # Number of knots
Region = "User", #User inputted extrapolation grid
purpose = "index2",
fine_scale = TRUE,
strata.limits =  data.frame("STRATA" = c("All_areas"),
"west_border" = -Inf,
"east_border" = Inf),
bias.correct = FALSE,
FieldConfig = c(
"Omega1" = 1,   #Spatial random effect on occurence
"Epsilon1" = 0, #Spatiotemporal random effect on occurence
"Omega2" = 1,   #Spatial random effect on positive response
"Epsilon2" = 0  #Spatiotemporal random effect on positive response
),
RhoConfig = c("Beta1" = 0,
"Beta2" = 0,
"Epsilon1" = 0,
"Epsilon2" = 0), #Each year is a fixed effect
OverdispersionConfig = c("Eta1" = 0,
"Eta2" = 0), #Turn off overdispersion
"Options" = c("Calculate_Range" = F,
"Calculate_effective_area" = F),
ObsModel = c(2, 1),
max_cells = Inf,
use_anisotropy = T)
##################################################
####   Import "true" and not interpolated covariate
####   data if using depth covariates
##################################################
load( paste0(github_dir, "data/Extrapolation_depths.RData"))
n_g <- nrow(Extrapolation_depths) #number of grid cells
n_t <- diff(range(Data_Geostat$Year)) + 1 #Number of total years
n_p <- 2 #two density covariates
X_gtp <- array(dim = c(n_g, n_t, n_p) )
for (i in 1:n_t) {
X_gtp[, i, ] <-
as.matrix(Extrapolation_depths[,c("LOG_DEPTH_EFH_CEN",
"LOG_DEPTH_EFH_CEN_SQ")])
}
##################################################
####   Fit the model and save output
##################################################
fit = switch(paste0(depth_in_model),
"FALSE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = result_dir,
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths),
"TRUE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = result_dir,
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths,
##Additional arguments for covariates
"X1_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"X2_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"covariate_data" = cbind(Data_Geostat[,c("Lat",
"Lon",
"LOG_DEPTH",
"LOG_DEPTH2",
"Catch_KG")],
Year = NA),
"X_gtp" = X_gtp )
)
##################################################
####   Save
##################################################
save(list = c("fit", "Data_Geostat"),
file = paste0(result_dir, "/fit.RData"))
##################################################
####   10-fold Cross Validation
##################################################
n_fold <- 10
for (fI in 1:n_fold) {
if (!dir.exists(paste0(result_dir, "CV_", fI))) {
dir.create(paste0(result_dir, "CV_", fI))
file.copy(from = paste0(result_dir, get_latest_version(),
c(".cpp", ".dll", ".o")),
to = paste0(result_dir, "CV_", fI, "/",
get_latest_version(),
c(".cpp", ".dll", ".o")))
}
}
# Loop through partitions, refitting each time with a different PredTF_i
for (fI in 1:n_fold ) {
PredTF_i <- ifelse( test = Data_Geostat$fold == fI,
yes = TRUE,
no = FALSE )
fit_new = switch(paste0(depth_in_model),
"FALSE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = paste0(result_dir, "CV_", fI, "/"),
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths,
"PredTF_i" = PredTF_i,
# "Parameters" = fit$ParHat,
"getsd" = T),
"TRUE" = FishStatsUtils::fit_model(
"settings" = settings,
"working_dir" = paste0(result_dir, "CV_", fI, "/"),
"Lat_i" = Data_Geostat[, "Lat"],
"Lon_i" = Data_Geostat[, "Lon"],
"t_i" = Data_Geostat[, "Year"],
"c_i" = as.numeric(Data_Geostat[, "spp"]) - 1,
"b_i" = Data_Geostat[, "Catch_KG"],
"a_i" = Data_Geostat[, "AreaSwept_km2"],
"getJointPrecision" = TRUE,
"newtonsteps" = 1,
"test_fit" = F,
"input_grid" = Extrapolation_depths,
"PredTF_i" = PredTF_i,
# "Parameters" = fit$ParHat,
"getsd" = T,
##Additional arguments for covariates
"X1_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"X2_formula" =  "Catch_KG ~ LOG_DEPTH + LOG_DEPTH2",
"covariate_data" = cbind(Data_Geostat[,c("Lat",
"Lon",
"LOG_DEPTH",
"LOG_DEPTH2",
"Catch_KG")],
Year = NA),
"X_gtp" = X_gtp )
)
# Save fit
save(list = "fit_new",
file = paste0(result_dir, "CV_", fI, "/fit.RData"))
}
}
}
packageVersion("memoise")
packageVersion("doParallel")
###############################################################################
## Project:       Synthesize Optimization Results
## Author:        Zack Oyafuso (zack.oyafuso@noaa.gov)
## Description:   Synthesize all optimization results
##                sample sizes, expected CVs, solutions, allocations, etc
###############################################################################
rm(list = ls())
##################################################
####  Set up directories
##################################################
which_machine <- c("Zack_MAC" = 1, "Zack_PC" = 2, "Zack_GI_PC" = 3)[2]
##################################################
####  Set up directories
##################################################
which_machine <- c("Zack_MAC" = 1, "Zack_PC" = 2, "Zack_GI_PC" = 3)[3]
github_dir <- paste0(c("/Users/zackoyafuso/Documents/",
"C:/Users/Zack Oyafuso/Documents/",
"C:/Users/zack.oyafuso/Work/")[which_machine],
"GitHub/Optimal_Allocation_GoA/")
##################################################
####   Import Packages
##################################################
library(SamplingStrata)
##################################################
####   Load Data
##################################################
load(paste0(github_dir, "data/optimization_data.RData"))
scen <- data.frame(domain = rep(c("district", "full_domain"), each = 2),
strata = c(3, 5, 10, 15))
###########################
## Empty Result objects
###########################
master_res_df <- data.frame(id = 1:n_cells)
master_settings <- master_settings_district <- data.frame()
master_strata_list <- master_strata_stats_list <- list()
idx <- 0
for(irow in 1:nrow(scen)) {
###########################
## Indices
##########################
idom <- scen$domain[irow]
istrata <- scen$strata[irow]
frame <- switch( idom,
"full_domain" = frame_all,
"district" = frame_district)
n_dom <- length(unique(frame$domainvalue))
for (iboat in 1:n_boats) {
result_dir <- paste0(github_dir, "results/", idom,
"/Multi_Species_Optimization/boat",
iboat, "/Str", istrata, "/")
runs <- grep(x = dir(result_dir),
pattern = "Run",
value = TRUE)
for (irun in runs) {
temp_dir <- paste0(result_dir,  irun, "/result_list.RData")
if (file.exists(temp_dir)) {
idx <- idx + 1
load(temp_dir)
## Solution: which strata is assigned to each extrapolation cell
solution <-
switch(idom,
"full_domain" = result_list$solution$indices$X1,
"district" = as.factor(paste(
result_list$solution$framenew$DOMAINVALUE,
result_list$solution$framenew$STRATO))
)
solution <- as.integer(solution)
master_res_df <- cbind(master_res_df,
solution )
## Strata characteristics: sample size, population, sampling rate,
## strata variable cuts
master_strata_list <- c(master_strata_list,
list(result_list[[2]]))
## Strata statistics (mean and variance)
temp_strata_stats_list <- result_list[[1]]$aggr_strata
strata_order <- order(as.integer(temp_strata_stats_list$DOM1))
temp_strata_stats_list <- temp_strata_stats_list[strata_order, ]
master_strata_stats_list <- c(master_strata_stats_list,
list(temp_strata_stats_list))
## High-level settings: total sample size and expected CV across
## species
species_cv <- switch(
idom,
"full_domain" = {
cv_agg <- result_list[[3]]
attributes(cv_agg)$dimnames[[1]] <- ""
attributes(cv_agg)$dimnames[[2]] <- paste0("CV", 1:ns_opt)
cv_agg
},
"district" = {
agg_strata <- result_list$solution$aggr_strata
agg_strata$STRATO <- 1:nrow(agg_strata)
agg_strata$DOM1 <- 1
cv_agg <- matrix(as.numeric(
SamplingStrata::expected_CV(strata = agg_strata)),
nrow = 1)
colnames(cv_agg) <- paste0("CV", 1:ns_opt)
cv_agg
})
n <- result_list$n
master_settings <- rbind(master_settings,
cbind(data.frame(domain = idom,
id = idx,
strata = istrata,
boat = iboat,
n), species_cv))
## High-level settings by district: total sample size and
## expected CV across species
species_cv <- result_list[[3]]
attributes(species_cv)$dimnames[[1]] <- rep("", n_dom)
attributes(species_cv)$dimnames[[2]] <- paste0("CV", 1:ns_opt)
master_settings_district <- rbind(
master_settings_district,
cbind(data.frame(id = idx,
boat = iboat,
strata = istrata,
domain = idom,
domain_no = 1:n_dom,
n = tapply(X = result_list$sum_stats$Allocation,
INDEX = result_list$sum_stats$Domain,
FUN = sum), species_cv))
)
}
}
}
}
##################################################
####   Subset to only the solutions closest to 280, 550, and 820
##################################################
idx <-  as.vector(
#First split master_settings by domain and strata level
sapply(X = split.data.frame(x = master_settings,
f = list(master_settings$domain,
master_settings$strata),
drop = TRUE,
sep = "_"),
## on each split, calculate which solution id is closest to the
## 1, 2, and 3, boat (280, 550, 820 stations) scenarios
FUN = function(x) {
sapply(X = samples,
FUN = function(y)
x$id[which.min(abs(x$n - y))])
}
)
)
settings <- subset(x = master_settings,
subset = id %in% idx,
select = -id)
settings
settings_district <- subset(x = master_settings_district,
subset = id %in% idx,
select = -id)
res_df <- master_res_df[, 1 + idx]
strata_list <- master_strata_list[idx]
strata_stats_list <- master_strata_stats_list[idx]
names(res_df) <- names(strata_list) <- names(strata_stats_list) <-
paste0("sol_", 1:nrow(settings))
##################################################
####   Adjust sample size
##################################################
for(irow in 1:nrow(settings)) {
temp_boat <- settings$boat[irow]
temp_n <-  settings$n[irow]
if((temp_n >= (samples[temp_boat] - 1) &
temp_n <= (samples[temp_boat] + 1)) ) next
temp_domain <- settings$domain[irow]
temp_strata <- settings$strata[irow]
temp_cv <- subset(x = settings_district,
subset = boat == temp_boat &
strata == temp_strata &
domain == temp_domain,
select = paste0("CV", 1:ns_opt))
temp_strata_stats_list <- subset(x = strata_stats_list[[irow]],
select = -SOLUZ)
n_dom <- ifelse(temp_domain == "full_domain", 1, 5)
temp_n_by_strata <- actual_n_by_strata <-
vector(length = nrow(temp_strata_stats_list))
names(temp_n_by_strata) <- names(actual_n_by_strata) <-
temp_strata_stats_list$DOM1
while ( !(temp_n >= (samples[temp_boat] - 1) &
temp_n <= (samples[temp_boat] + 1)) ) {
over_or_under <- temp_n > samples[temp_boat]
temp_cv <- temp_cv * (1 + ifelse(test = over_or_under == T,
yes = 0.0005,
no = -0.0005))
temp_n_by_reg <- vector(length = n_dom)
for (i in 1:n_dom) {
error_df <- cbind(data.frame("DOM" = "DOM1",
temp_cv[i, ],
"domainvalue"  = 1))
temp_bethel <- SamplingStrata::bethel(
errors = error_df,
stratif = subset(x = temp_strata_stats_list, subset = DOM1 == i),
realAllocation = T,
printa = T)
temp_n_by_reg[i] <- sum(as.numeric(ceiling(temp_bethel)))
temp_n_by_strata[names(temp_n_by_strata) == paste(i)] <- ceiling( temp_bethel)
actual_n_by_strata[names(actual_n_by_strata) == paste(i)] <- temp_bethel
}
temp_n <- sum(temp_n_by_reg)
print(temp_n)
}
temp_cv_agg <- SamplingStrata::expected_CV(
strata = cbind(subset(temp_strata_stats_list,
select = -DOM1),
DOM1 = 1,
SOLUZ = actual_n_by_strata))
####################################
## Record new results
####################################
settings[irow, paste0("CV", 1:ns_opt)] <- as.numeric(temp_cv_agg)
settings[irow, "n"] <- temp_n
strata_stats_list[[irow]]$SOLUZ <- actual_n_by_strata
strata_list[[irow]]$Allocation <- temp_n_by_strata
settings_district[settings_district$boat == temp_boat &
settings_district$strata == temp_strata &
settings_district$domain == temp_domain,
paste0("CV", 1:ns_opt)] <- temp_cv
}
settings
##################################################
####   Save Objects
##################################################
save(list = c("res_df", "settings", "settings_district",
"strata_list", "strata_stats_list"),
file = paste0(github_dir,
"results/MS_optimization_knitted_results.RData"))
source('~/.active-rstudio-document', echo=TRUE)
warnings()
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
